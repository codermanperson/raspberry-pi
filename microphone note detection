import numpy as np
import sounddevice as sd
from scipy.fft import rfft, rfftfreq
import time
from datetime import datetime
import os
from collections import deque

# Constants
SAMPLE_RATE = 44100
CHUNK_SIZE = 2048
NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
VOLUME_THRESHOLD = 0.05
MIN_FREQ = 100  # Bb2 (below sax range for overtones)
MAX_FREQ = 1500 # F6 (above sax range)

# Note stabilization
NOTE_CHANGE_THRESHOLD = 3  # Minimum semitone difference to change notes
STABLE_FRAMES_REQUIRED = 3  # How many consistent frames before changing

BPM = 120  # ‚Üê Add this line to control overall tempo
BEAT_VALUE = 60.0 / BPM  # Duration of one beat in seconds

# Then modify the RHYTHM_MAP to use BEAT_VALUE:
RHYTHM_MAP = {
    0.125 * BEAT_VALUE * 4: '32nd',
    0.25 * BEAT_VALUE * 4: '16th',
    0.375 * BEAT_VALUE * 4: '16th.',
    0.5 * BEAT_VALUE * 4: 'eighth',
    0.75 * BEAT_VALUE * 4: 'eighth.',
    1.0 * BEAT_VALUE * 4: 'quarter',
    1.5 * BEAT_VALUE * 4: 'quarter.',
    2.0 * BEAT_VALUE * 4: 'half',
    3.0 * BEAT_VALUE * 4: 'half.',
    4.0 * BEAT_VALUE * 4: 'whole'
}
VOLUME_THRESHOLD = 0.05                  # Silence detection level (0.01-0.1)
MIN_REST_DURATION = 0.2 * (60/BPM)       # Shortest gap considered a rest (seconds)

# Rest type thresholds (multipliers are relative to quarter note)
REST_THRESHOLDS = {
    0.4: 'rest.16th',    # 0.4x quarter note duration
    0.8: 'rest.eighth',  # 0.8x
    1.1: 'rest.quarter', # 1.1x 
    2.3: 'rest.half',    # 2.3x
    4.5: 'rest.whole'    # 4.5x
}

# Convert to absolute times based on BPM
RHYTHM_MAP = {
    # Notes (auto-generated)
    **{0.125 * (60/BPM) * 4: '32nd'},
    **{0.25 * (60/BPM) * 4: '16th'},
    # ... other note values ...
    
    # Rests (calculated from thresholds)
    **{thresh * (60/BPM): name for thresh, name in REST_THRESHOLDS.items()}
}
# ======================

# [Rest of your existing code...]

def audio_callback(indata, frames, time_info, status):
    global current_note, note_start_time, rest_start_time
    
    volume = np.sqrt(np.mean(indata**2))
    current_time = time.time()
    
    # Rest detection logic
    if volume < VOLUME_THRESHOLD:
        if current_note:  # Transition to rest
            log_note_duration(current_time - note_start_time)
            current_note = None
            rest_start_time = current_time
        elif rest_start_time and (current_time - rest_start_time) > MIN_REST_DURATION:
            rest_duration = current_time - rest_start_time
            log_file.write(f"{get_rest_type(rest_duration)}\n")
        return
    
# Global variables
current_note = None
note_start_time = None
log_file = None
stable_frames = 0
last_detected_note = None

def init_log_file():
    global log_file
    os.makedirs("sax_notes", exist_ok=True)
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = open(f"sax_notes/notes_{timestamp}.txt", "w")

def get_rhythm(duration):
    closest = min(RHYTHM_MAP.keys(), key=lambda x: abs(x - duration))
    return RHYTHM_MAP[closest]

def freq_to_note_num(freq):
    """Convert frequency to semitone position (0=C, 1=C#, etc.)"""
    return int(round(12 * np.log2(max(1, freq) / 440.0) + 69) % 12

def is_significant_change(new_note_num):
    """Check if pitch change is large enough"""
    if current_note is None:
        return True
    current_num = NOTE_NAMES.index(current_note)
    return abs(new_note_num - current_num) >= NOTE_CHANGE_THRESHOLD

    
    # Process audio
    fft_data = np.abs(rfft(indata[:, 0]))
    freqs = rfftfreq(len(indata[:, 0]), 1.0/SAMPLE_RATE)
    
    # Focus on saxophone frequency range
    valid_mask = (freqs >= MIN_FREQ) & (freqs <= MAX_FREQ)
    if not np.any(valid_mask):
        return
    
    peak_freq = freqs[valid_mask][np.argmax(fft_data[valid_mask])]
    new_note_num = freq_to_note_num(peak_freq)
    new_note = NOTE_NAMES[new_note_num]
    
    # Note stabilization logic
    if new_note == last_detected_note:
        stable_frames += 1
    else:
        stable_frames = 0
        last_detected_note = new_note
    
    # Only change note if stable and significant difference
    if (stable_frames >= STABLE_FRAMES_REQUIRED and 
        is_significant_change(new_note_num)):
        
        if current_note:
            duration = time.time() - note_start_time
            rhythm = get_rhythm(duration)
            log_file.write(f"{rhythm} {current_note}\n")
            print(f"{rhythm} {current_note}")
        
        current_note = new_note
        note_start_time = time.time()
        stable_frames = 0

def main():
    init_log_file()
    print(f"Saxophone Note Detector\n"
          f"Note change threshold: {NOTE_CHANGE_THRESHOLD} semitones\n"
          f"Stability frames: {STABLE_FRAMES_REQUIRED}\n")
    
    try:
        with sd.InputStream(
            callback=audio_callback,
            channels=1,
            samplerate=SAMPLE_RATE,
            blocksize=CHUNK_SIZE,
            dtype='float32'
        ):
            while True:
                time.sleep(0.1)
    except KeyboardInterrupt:
        print("\nStopping...")
    finally:
        if log_file:
            log_file.close()

if __name__ == "__main__":
    main()
